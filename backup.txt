package testSeq

import (
	"bytes"
	"context"
	"encoding/hex"
	"encoding/json"

	//	"errors"
	"fmt"
	"io"
	"log"
	"mime/multipart"

	"main/apiGateway"
	Configuration "main/config"
	"main/database"
	spirentapi "main/spirentAPI"
	"main/systemUnderTest"
	"net"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	//"io/ioutil"
	"github.com/fatih/color"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/ishidawataru/sctp"
	"github.com/sirupsen/logrus"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var Address string

var Cdr_Validator_Server string

type SutInit struct {
	Type   string `json:"type"`
	Config struct {
		IpAddress string `json:"ip_address"`
		Protocol  string `json:"protocol"`
	} `json:"config"`
}

type RespData4GE2E struct {
	Data struct {
		Status            string      `json:"status"`
		Wireshark_Message interface{} `json:"wireshark_messages"`
		Diagram_Name      string      `json:"diagram_name"`
		Validation        string      `json:"validation"`
		Validation_step   interface{} `json:"validation_steps"`
	} `json:"data"`
	Request_Id  string `json:"request_id"`
	Release     string `json:"release_version"`
	CdrResponse string `json:"cdr_response"`
}

type RespData5gInterface struct {
	Response           interface{} `json:"response"`
	CorrectRequestBody bool        `json:"corrected_request_body"`
	Release            string      `json:"release_version"`
	Protocol           string      `json:"http_protocol"`
	Header             interface{} `json:"header"`
}

type RespData5gE2e struct {
	Response   interface{} `json:"response"`
	ConfigPath string      `json:"config_path"`
	Protocol   string      `json:"protocol"`
}

type TestStruct struct {
	Sut             systemUnderTest.Sut `json:"sut"`
	Supporting_Node []Supporting_Node   `json:"supporting_node"`
	Emulated        struct {
		Name      string `json:"name"`
		Ipaddress string `json:"ip_address"`
	} `json:"emulated"`
	Release struct {
		ReleaseValue          string `json:"release_value"`
		RequestBodyCorrection bool   `json:"request_body_correction"`
	} `json:"release"`
	Tech           string `json:"tech"`
	TestType       string `json:"test_type"`
	Cdr_Validation bool   `json:"cdr_validation"`
	Messages       []struct {
		RequestType string `json:"request_type"`
		EndPoint    string `json:"end_point"`
		Name        string `json:"message_name"`
		MConfig     struct {
			Body  interface{}            `json:"body,string"`
			Path  map[string]interface{} `json:"path"`
			Query map[string]interface{} `json:"query"`
		} `json:"message_config"`
		Params             []string               `json:"params"`
		ParamsValue        map[string]interface{} `json:"params_value"`
		QueryParams        []string               `json:"query_params"`
		QueryParamsValue   map[string]interface{} `json:"query_params_value"`
		Description        string                 `json:"description"`
		ExpectedStatusCode string                 `json:"status_code"`
		ResponseMessage    map[string]interface{} `json:"response_message"`
	} `json:"messages"`
	Procedure struct {
		ProcedureId   string `json:"procedure_id"`
		ProcedureName string `json:"procedure_name"`
		RequestType   string `json:"request_type"`
		EndPoint      string `json:"end_point"`
		Configs       []struct {
			FileName string      `json:"file_name"`
			FileBody interface{} `json:"file_body,string"`
		} `json:"configs"`
		Delays []struct {
			FileName string      `json:"file_name"`
			FileBody interface{} `json:"file_body,string"`
		} `json:"delays"`
		Description        string                 `json:"description"`
		ExpectedStatusCode string                 `json:"status_code"`
		ResponseMessage    map[string]interface{} `json:"response_message"`
	} `json:"procedure"`
}

type TestMessage struct {
	EmulatedIP           string
	EmulatedName         string
	RequestMessageConfig map[string]interface{}
	ExpectedResponseCode string
	Result               string
}

type Supporting_Node struct {
	Node          string `json:"node"`
	ActiveNodeIp  string `json:"active_node_ip"`
	StandByNodeIp string `json:"standby_node_ip"`
}

var TS []TestStruct

type ResponseMsg struct {
	Name             string      `json:"name"`
	Response         interface{} `json:"response"`
	StatusCode       string      `json:"status_code"`
	ValidationResult string      `json:"validation_result"`
}

type ResponseQueueElement struct {
	ResponseData [][]ResponseMsg `json:"response_data"`
	Error        string          `json:"error"`
	IsCompleted  bool            `json:"is_completed"`
}

var ResponseQueue map[string]ResponseQueueElement

type ParamValue struct {
	Param string `json:"param"`
}

func init() {
	ResponseQueue = make(map[string]ResponseQueueElement)
}

type SaveSutURI struct {
	Uri string `json:"uri"`
}

type SaveSutNAME struct {
	Name string `json:"name"`
}

type SaveEmuURI struct {
	Uri []string `json:"uri"`
}

type SaveSutScheme struct {
	Scheme string `json:"scheme"`
}

type SaveMiddlewareURI struct {
	Uri string `json:"uri"`
}

func GetMiddlewareUri() (string, error) {

	var ctx = context.TODO()
	var Middleware_Uri SaveMiddlewareURI
	if Address == "" {
		filter := bson.M{}
		collName := "Middleware_URI"
		collection := database.OpenCollection(collName)
		err := collection.FindOne(ctx, filter).Decode(&Middleware_Uri)
		if err != nil {
			log.Println(err)
			return "", err
		}
		return Middleware_Uri.Uri, nil
	} else {
		sut_uri := Address
		return sut_uri, nil
	}
}

func Get_Emu_URI() ([]string, error) {

	var ctx = context.TODO()
	var Emu_Uri SaveEmuURI
	filter := bson.M{}
	collName := "EMU_URI"
	collection := database.OpenCollection(collName)
	err := collection.FindOne(ctx, filter).Decode(&Emu_Uri)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return Emu_Uri.Uri, nil
}
func GetSut_Base_URI_token(token string) (string, error) {

	var COLL_NAME = "sut_user"
	var sut_user_collection *mongo.Collection = database.OpenCollection(COLL_NAME)
	var ctx = context.TODO()
	var podcast bson.M
	var err error
	fmt.Println("the token is", token)
	if err = sut_user_collection.FindOne(ctx, bson.M{"id": token}).Decode(&podcast); err != nil {
		fmt.Println(err)
	}
	fmt.Println("the podcast is ", podcast)
	sut_uri := podcast["sut_uri"].(string)
	return sut_uri, nil
}

func GetSut_Base_URI() (string, error) {

	var ctx = context.TODO()
	var Sut_Base_Uri_struct SaveSutURI
	if TS[0].Sut.IpAddress == "" {
		filter := bson.M{}
		collName := "SUT_URI"
		collection := database.OpenCollection(collName)
		err := collection.FindOne(ctx, filter).Decode(&Sut_Base_Uri_struct)
		if err != nil {
			log.Println(err)
			return "", err
		}
		return Sut_Base_Uri_struct.Uri, nil
	} else {
		sut_uri := TS[0].Sut.Protocol + "://" + TS[0].Sut.IpAddress
		return sut_uri, nil
	}
}

func SetSutBaseUriToken(sutUri string, token string) {

	var COLL_NAME = "sut_user"
	var sut_user_collection *mongo.Collection = database.OpenCollection(COLL_NAME)
	var ctx = context.TODO()
	// 5) Create the search filter
	filter := bson.M{"id": token}

	// 6) Create the update
	update := bson.M{
		"$set": bson.M{"sut_uri": sutUri},
	}

	// 7) Create an instance of an options and set the desired options
	upsert := true
	after := options.After
	opt := options.FindOneAndUpdateOptions{
		ReturnDocument: &after,
		Upsert:         &upsert,
	}

	// 8) Find one result and update it
	result := sut_user_collection.FindOneAndUpdate(ctx, filter, update, &opt)
	if result.Err() != nil {
		fmt.Println(nil, result.Err())
	}

	// 9) Decode the result
	doc := bson.M{}
	decodeErr := result.Decode(&doc)
	fmt.Println(decodeErr)
	fmt.Println("New SUT Uri added successfully, via customer token")
}

func SetSutBaseUri(sutUri string) {

	var ctx = context.TODO()
	collName := "SUT_URI"
	collection := database.OpenCollection(collName)
	_, err := collection.DeleteOne(ctx, bson.M{})
	log.Println("DELETION DONE OF OLD SUT URI")
	if err != nil {
		log.Println(err)
		return
	}
	fmt.Println("DELETION DONE OF OLD SUT URI")
	var svethisUri SaveSutURI
	svethisUri.Uri = sutUri
	_, err = collection.InsertOne(ctx, svethisUri)
	if err != nil {
		log.Println(err)
		return
	}
	fmt.Println("ADDED NEW SUT URI")
}

func setSutName(sutName string) {

	var ctx = context.TODO()
	collName := "SUT_NAME"
	collection := database.OpenCollection(collName)
	_, err := collection.DeleteOne(ctx, bson.M{})
	log.Println("DELETION DONE OF OLD SUT URI")
	if err != nil {
		log.Println(err)
		return
	}
	fmt.Println("DELETION DONE OF OLD SUT URI")
	var svethisName SaveSutNAME
	svethisName.Name = sutName
	_, err = collection.InsertOne(ctx, svethisName)
	if err != nil {
		log.Println(err)
		return
	}
	fmt.Println("ADDED NEW SUT URI")
}

func SetSutBaseScheme(sutScheme string) {

	var ctx = context.TODO()
	collName := "SUT_SCHEME"
	collection := database.OpenCollection(collName)
	_, err := collection.DeleteOne(ctx, bson.M{})
	log.Println("DELETION DONE OF OLD SUT SCHEME")
	if err != nil {
		log.Println(err)
		return
	}
	fmt.Println("DELETION DONE OF OLD SUT SCHEME")
	var svethisScheme SaveSutScheme
	svethisScheme.Scheme = sutScheme
	_, err = collection.InsertOne(ctx, svethisScheme)
	if err != nil {
		log.Println(err)
		return
	}
	fmt.Println("ADDED NEW SUT SCHEME")
}

type DefaultParams struct {
	Params map[string]interface{} `json:"params"`
}

func GetDefaultParams(c *gin.Context) {

	var ctx = context.TODO()
	var defaultParams DefaultParams
	filter := bson.M{}
	collName := "Default_Params"
	collection := database.OpenCollection(collName)
	err := collection.FindOne(ctx, filter).Decode(&defaultParams)
	if err != nil {
		log.Println(err)
	}
	c.JSON(http.StatusOK, defaultParams)
}

func UpdateDefaultParams(c *gin.Context) {

	var ctx = context.TODO()
	var defParam DefaultParams
	e2 := c.BindJSON(&defParam)
	if e2 != nil {
		c.JSON(http.StatusInternalServerError, e2)
		return
	}
	collName := "Default_Params"
	collection := database.OpenCollection(collName)
	_, err := collection.DeleteOne(ctx, bson.M{})
	if err != nil {
		log.Println(err)
		return
	}
	_, err = collection.InsertOne(ctx, defParam)
	if err != nil {
		log.Println(err)
		return
	}
	fmt.Println("UPDATED DEFAULT PARAMS")
}

func Stop(c *gin.Context) {
	user_email := apiGateway.FetchUserEmail(c)
	IP := apiGateway.GenerateHost4ge2e(user_email)
	URL := "http://" + IP + "/stop_process"
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)

}

func Show_Spirent_Diagram(c *gin.Context) {
	config := Configuration.ReadConfig()
	IP := config.CDR.Forward_Spirent_Host.IP + ":" + config.CDR.Forward_Spirent_Host.Port
	filename := c.Param("filename")
	URL := "http://" + IP + "/GetFileToDownload/" + filename
	fmt.Println(URL)
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	//       var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	/*   err = json.Unmarshal(bod, &resp)
	     if err != nil {
	             fmt.Println(err)
	     }*/
	c.Header("Content-Type", "text/html")
	c.String(http.StatusOK, string(bod))
}

func Diagram(c *gin.Context) {
	user_email := apiGateway.FetchUserEmail(c)
	IP := apiGateway.GenerateHost4ge2e(user_email)
	fileName := c.Param("fileName")
	URL := "http://" + IP + "/getDiagram/" + fileName
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	//       var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	/*   err = json.Unmarshal(bod, &resp)
	     if err != nil {
	             fmt.Println(err)
	     }*/
	c.Header("Content-Type", "text/html")
	c.String(http.StatusOK, string(bod))
}

func StopNodes(c *gin.Context) {
	client := &http.Client{}
	emu_uri_list, _ := Get_Emu_URI()

	emu_uri_list = append(emu_uri_list, "10.254.12.254:8010")
	fmt.Println(emu_uri_list)

	for i := 0; i < len(emu_uri_list); i++ {

		base_url := "http://" + emu_uri_list[i] + "/terminate"
		req, err := http.NewRequest("GET", base_url, nil)
		if err != nil {
			log.Println(err)
			c.JSON(http.StatusInternalServerError, err)
			return
		}

		resp, err := client.Do(req)
		if err != nil {
			log.Println(err)
			c.JSON(http.StatusInternalServerError, err)
			return
		}
		fmt.Println(resp)
	}
}

func FetchParamFromDB(param string) (string, error) {

	var ctx = context.TODO()
	var paramValue ParamValue
	filter := bson.M{}
	collName := param
	collection := database.OpenCollection(collName)
	err := collection.FindOne(ctx, filter).Decode(&paramValue)
	if err != nil {
		log.Println(err)
		return "", err
	}
	return paramValue.Param, nil
}

func Ping(IP, Protocol, server_name string) (bool, string) {

	if Protocol == "NGAP" {
		amfAddrData := strings.Split(IP, ":")
		if len(amfAddrData) != 2 {
			return false, "Port missing :" + amfAddrData[0] + ":<port>"
		}
		amfAddr, _ := net.ResolveIPAddr("ip", amfAddrData[0])
		amfPort, _ := strconv.Atoi(amfAddrData[1])
		ips := []net.IPAddr{*amfAddr}
		addr := &sctp.SCTPAddr{
			IPAddrs: ips,
			Port:    amfPort,
		}
		_, err := sctp.DialSCTPExt("sctp", nil, addr, sctp.InitMsg{NumOstreams: 1, MaxInstreams: 1, MaxAttempts: 2, MaxInitTimeout: 5})
		if err != nil {
			return false, server_name + " not running at " + IP
		} else {
			return true, ""
		}
	} else if Protocol == "S1AP" {
		mmeAddrData := strings.Split(IP, ":")
		if len(mmeAddrData) != 2 {
			return false, "Port missing " + mmeAddrData[0] + ":<port>"
		}
		mmeAddr, _ := net.ResolveIPAddr("ip", mmeAddrData[0])
		mmePort, _ := strconv.Atoi(mmeAddrData[1])
		ips := []net.IPAddr{*mmeAddr}
		addr := &sctp.SCTPAddr{
			IPAddrs: ips,
			Port:    mmePort,
		}
		conn, err := sctp.DialSCTPExt("sctp", nil, addr, sctp.InitMsg{NumOstreams: 1, MaxInstreams: 1, MaxAttempts: 2, MaxInitTimeout: 5})
		fmt.Println("server ping", conn)
		if err != nil {
			return false, server_name + " not running at " + IP
		} else {
			return true, ""
		}
	} else {
		timeout := time.Duration(1 * time.Second)
		_, err := net.DialTimeout("tcp", IP, timeout)
		fmt.Println("sname:", server_name, "op:", len(IP))
		if err != nil {
			if len(IP) <= 2 {
				return false, "Container not assigned to user"
			} else {
				return false, server_name + " is not running at " + IP
			}

		}

		return true, ""
	}
}

func GetTestSeqResult(c *gin.Context) {
	resId := c.Param("resultId")
	fmt.Println(resId)
	fmt.Println(ResponseQueue)
	fmt.Println(ResponseQueue[resId])
	result, isPresent := ResponseQueue[resId]
	if isPresent {
		if !result.IsCompleted {
			c.JSON(http.StatusTooEarly, "Process still running!")
		} else {
			if result.Error != "" {
				c.JSON(http.StatusOK, result.Error)
			} else {
				c.JSON(http.StatusOK, result.ResponseData)
			}
		}
	} else {
		c.JSON(http.StatusNotFound, "No Such Process exists!")
	}
}

func GetLiveLogId(c *gin.Context) {
	email := c.Param("user_email")
	//var mutex sync.Mutex
	Mutex_Lock.Lock()
	val := Livelog_map[email]
	Mutex_Lock.Unlock()

	c.JSON(http.StatusOK, val)

}
func DeleteIds(c *gin.Context) {
	user := c.Param("user_email")
	type deleteIds struct {
		Message []string `json:"message"`
	}
	var delId deleteIds
	e := c.BindJSON(&delId)
	if e != nil {
		fmt.Print("errorr!!!!!!!!!!!!!!!!!!!!!!!!!")
	}
	//	fmt.Println("Messages : ", delId.Message)
	//	fmt.Println("user:", Livelog_map[user])
	//var mutex sync.Mutex
	for i, _ := range delId.Message {
		Mutex_Lock.Lock()
		fmt.Println(Livelog_map[user], delId.Message[i])
		delete(Livelog_map[user], delId.Message[i])
		Mutex_Lock.Unlock()
	}
	c.JSON(http.StatusOK, "deleted")
}

func InitiateTesting(c *gin.Context) {

	e2 := c.BindJSON(&TS)
	if e2 != nil {
		fmt.Println("Error in mapping req body with TestInitiate struct")
		c.JSON(http.StatusInternalServerError, e2)
		fmt.Println("Error in mapping req body with TestInitiate struct")
		return
	}
	user_email := apiGateway.FetchUserEmail(c)
	var IP string
	var TC_Name string
	if TS[0].Tech == "5G" && TS[0].TestType == "INTERFACE" {
		IP = apiGateway.GenerateHost5gInterface(user_email)
		TC_Name = TS[0].Messages[0].Name
	} else if TS[0].Tech == "5G" && TS[0].TestType == "E2E" {
		IP = apiGateway.GenerateHost5ge2e(user_email)
		TC_Name = TS[0].Procedure.ProcedureName
	} else if TS[0].Tech == "4G" && TS[0].TestType == "E2E" {
		IP = apiGateway.GenerateHost4ge2e(user_email)
		TC_Name = TS[0].Procedure.ProcedureName
	} else if TS[0].Tech == "Interrat" && TS[0].TestType == "Interrat" {
		IP = apiGateway.GenerateHostInterrat(user_email)
		TC_Name = TS[0].Procedure.ProcedureName
	}
	//var mutex sync.Mutex

	new_uuid := uuid.New().String()
	//	go InitiateTestingProcedure(user_email, uuid)
	uuid := IP + "@" + new_uuid

	if TS[0].Tech == "4G" && TS[0].TestType == "E2E" {
		Mutex_Lock.Lock()
		if Livelog_map == nil {
			Livelog_map = make(map[string]map[string]string)
			Livelog_map[user_email] = make(map[string]string)
		}
		if Livelog_map[user_email] == nil {
			Livelog_map[user_email] = make(map[string]string)
		}
		Livelog_map[user_email]["TI#"+TC_Name] = uuid
		Mutex_Lock.Unlock()
	}
	//	c.JSON(http.StatusOK, gin.H{"live_result_id": uuid})

	respList, _ := InitiateTestingProcedure(user_email, new_uuid)
	c.JSON(http.StatusOK, respList)
}

func GetLiveLog(c *gin.Context) {
	Log_id := c.Param("id")
	IP := strings.Split(Log_id, "@")
	if len(IP) != 2 {
		fmt.Println("error")
	}
	URL := "http://" + IP[0] + "/live_logs/" + IP[1]
	fmt.Println("URL:", URL)
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)
}

func InitiateTestingProcedure(user_email string, uuid string) ([][]ResponseMsg, error) {

	var respList [][]ResponseMsg
	var err error
	var ele ResponseQueueElement
	ele.IsCompleted = false
	ResponseQueue[uuid] = ele
	if TS[0].Tech == "5G" && TS[0].TestType == "INTERFACE" {
		respList, err = Initiate5gInterfaceTest(user_email)
	} else if TS[0].Tech == "5G" && TS[0].TestType == "E2E" {
		respList, err = Initiate5gE2eTest(user_email)
	} else if TS[0].Tech == "4G" && TS[0].TestType == "E2E" {
		respList, err = Initiate4gE2eTest(user_email, uuid)
	} else if TS[0].Tech == "Interrat" && TS[0].TestType == "Interrat" {
		respList, err = InitiateInterratTest(user_email, uuid)
	}
	ele.ResponseData = respList
	if err != nil {
		ele.Error = err.Error()
	}
	ele.IsCompleted = true
	ResponseQueue[uuid] = ele
	return respList, err
}

func Initiate5gInterfaceTest(user_email string) ([][]ResponseMsg, error) {
	f, err := os.OpenFile("/home/cicdtools/NfstubLogs/2nrf.log", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		fmt.Printf("error opening file: %v", err)
	}
	logrus.SetFormatter(&logrus.JSONFormatter{})
	logrus.SetOutput(f)
	logrus.SetLevel(logrus.DebugLevel)
	var finalresp [][]ResponseMsg
	for k := 0; k < len(TS); k++ {
		Temp := TS[k]
		Temp.Sut.Interface = ""
		client := &http.Client{}
		token := Temp.Sut.Token
		sutScheme := Temp.Sut.Protocol
		fmt.Println("The user token is ", token)
		sutIp := sutScheme + "://" + Temp.Sut.IpAddress
		fmt.Println(sutIp)

		testSeqId := uuid.New().String()
		SetSutBaseScheme(sutScheme)
		SetSutBaseUri(sutIp)
		setSutName(Temp.Sut.Name)
		SetSutBaseUriToken(sutIp, token)
		var respList []ResponseMsg
		var res ResponseMsg
		var valResult string
		ok, msg := Ping(Temp.Sut.IpAddress, Temp.Sut.Protocol, "sut")
		if !ok {
			res.Name = Temp.Procedure.ProcedureName
			res.StatusCode = "500"
			res.ValidationResult = "Fail"
			res.Response = msg
			respList = append(respList, res)
			finalresp = append(finalresp, respList)
			return finalresp, nil
		}
		Temp.Emulated.Ipaddress = apiGateway.GenerateHost5gInterface(user_email)
		ok1, msg1 := Ping(Temp.Emulated.Ipaddress, "HTTP", "Interface-5g-container")
		if !ok1 {
			res.Name = Temp.Procedure.ProcedureName
			res.StatusCode = "500"
			res.ValidationResult = "Fail"
			res.Response = msg1
			respList = append(respList, res)
			finalresp = append(finalresp, respList)
			return finalresp, nil
		}
		b_url := "/release?"
		if !Temp.Release.RequestBodyCorrection {
			b_url += "correctRequestBody=false"
		} else {
			b_url += "correctRequestBody=true"
		}
		if Temp.Release.ReleaseValue != "" {
			b_url += "&releaseVersion=" + Temp.Release.ReleaseValue
		}
		_, _ = apiGateway.Forward5gInterfaceReq(user_email, "GET", b_url, nil)
		for i := 0; i < len(Temp.Messages); i++ {

			tempEndPoint := Temp.Messages[i].EndPoint
			for j, k := range Temp.Messages[i].MConfig.Path {
				if k != nil {
					replaceStr := ":" + j
					tempEndPoint = strings.Replace(tempEndPoint, replaceStr, fmt.Sprint(k), 1)
				}
			}
			if len(Temp.Messages[i].MConfig.Query) > 0 {
				tempEndPoint += "?"
				for j, k := range Temp.Messages[i].MConfig.Query {
					if k != nil {
						tempEndPoint += j + string('=') + fmt.Sprint(k) + string('&')
					}
				}
				tempEndPoint = tempEndPoint[:len(tempEndPoint)-1]
			}
			var base_url string
			check_str := strings.Contains(tempEndPoint, "?")
			base_url = "http://" + Temp.Emulated.Ipaddress + tempEndPoint + "?token=" + token
			if check_str {
				base_url = "http://" + Temp.Emulated.Ipaddress + tempEndPoint + "&token=" + token
			}
			fmt.Println(base_url)
			reqbody := fmt.Sprint(Temp.Messages[i].MConfig.Body)
			if strings.Contains(reqbody, "map[") {
				jsdata, _ := json.Marshal(Temp.Messages[i].MConfig.Body)
				reqbody = string(jsdata)
			}
			if strings.Contains(reqbody, "<nil>") {
				reqbody = ""
			}
			payload := strings.NewReader(reqbody)
			req, err := http.NewRequest(Temp.Messages[i].RequestType, base_url, payload)
			if err != nil {
				return finalresp, err
			}
			req.Header.Add("Accept", "*/*") /*   */
			resp, err := client.Do(req)
			if err != nil {
				return finalresp, err
			}
			ExpectedStatusMsg := strings.Split(Temp.Messages[i].ExpectedStatusCode, " ")
			ExpectedStatusMsgLength := len(ExpectedStatusMsg)
			if Temp.Messages[i].Name == "gnb" || Temp.Messages[i].Name == "upf" {
				if strconv.Itoa(resp.StatusCode) == "200" && (ExpectedStatusMsg[ExpectedStatusMsgLength-1] == "Response" || ExpectedStatusMsg[ExpectedStatusMsgLength-1] == "Request") {
					valResult = "Pass"
					res.StatusCode = Temp.Messages[i].ExpectedStatusCode
				} else if strconv.Itoa(resp.StatusCode) == "500" && ExpectedStatusMsg[ExpectedStatusMsgLength-1] == "Failure" {
					valResult = "Pass"
					res.StatusCode = Temp.Messages[i].ExpectedStatusCode
				} else if strconv.Itoa(resp.StatusCode) == "500" && ExpectedStatusMsg[ExpectedStatusMsgLength-1] == "Response" {
					valResult = "Fail"
					res.StatusCode = "Failure"
				} else {
					valResult = "Fail"
					res.StatusCode = "Response"
				}
			} else {
				if strconv.Itoa(resp.StatusCode) == Temp.Messages[i].ExpectedStatusCode {
					valResult = "Pass"
				} else {
					valResult = "Fail"
				}
				res.StatusCode = strconv.Itoa(resp.StatusCode)
			}

			res.ValidationResult = valResult
			res.Name = Temp.Messages[i].Name
			var Respdata5ginterface RespData5gInterface
			if res.StatusCode == "204" {
				Respdata5ginterface.CorrectRequestBody = TS[k].Release.RequestBodyCorrection
				Respdata5ginterface.Release = TS[k].Release.ReleaseValue
				if TS[k].Sut.Protocol == "http" {
					Respdata5ginterface.Protocol = "HTTP 1.1"
				} else if TS[k].Sut.Protocol == "https" {
					Respdata5ginterface.Protocol = "HTTP 2"
				} else {
					Respdata5ginterface.Protocol = TS[k].Sut.Protocol
				}
				res.Response = Respdata5ginterface
			} else {
				bod, _ := io.ReadAll(resp.Body)
				_ = json.Unmarshal(bod, &Respdata5ginterface)
				var resTemp RespData5gInterface
				if Respdata5ginterface == resTemp {
					res.Response = bod
				} else {
					res.Response = Respdata5ginterface
				}
			}
			respList = append(respList, res)

			logrus.WithFields(logrus.Fields{
				// "Body": Temp,
				"TestSequenceId": testSeqId,
				"User":           user_email,
				// "Emulated_Node":    Temp.Messages[0].Name,
				// "Emulated_Node_IP": Temp.Messages[0].Ipaddress,
				"SUT_Name": Temp.Sut.Name,
				"SUT_IP":   Temp.Sut.IpAddress,
				"Action":   "Initiate Test",
				// "Result":           resultList,
				// "Test_Messages":    Temp.Messages,
				"EmulatedIP":           Temp.Emulated.Ipaddress,
				"EmulatedName":         Temp.Emulated.Name,
				"RequestMessageConfig": Temp.Messages[i].MConfig,
				"ExpectedStatusCode":   Temp.Messages[i].ExpectedStatusCode,
				"MessageName":          Temp.Messages[i].Name,
				"Result":               valResult,
				"Response":             res,
			}).Info("Initiate Test")
		}
		finalresp = append(finalresp, respList)
	}
	fmt.Println(finalresp)
	var tmp TestStruct
	if len(TS) > 0 {
		tmp.Sut = TS[0].Sut
		tmp.Emulated = TS[0].Emulated
	}
	TS = nil
	if len(TS) > 0 {
		TS = append(TS, tmp)
	}
	return finalresp, nil
}

func Initiate5gE2eTest(user_email string) ([][]ResponseMsg, error) {
	f, err := os.OpenFile("/home/cicdtools/NfstubLogs/2nrf.log", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		fmt.Printf("error opening file: %v", err)
	}
	logrus.SetFormatter(&logrus.JSONFormatter{})
	logrus.SetOutput(f)
	logrus.SetLevel(logrus.DebugLevel)
	var finalresp [][]ResponseMsg
	Temp := TS[0]
	fmt.Println(Temp.Procedure)
	Temp.Sut.Interface = ""
	client := &http.Client{}
	token := Temp.Sut.Token
	sutScheme := Temp.Sut.Protocol
	fmt.Println("The user token is ", token)
	sutIp := sutScheme + "://" + Temp.Sut.IpAddress
	fmt.Println(sutIp)

	testSeqId := uuid.New().String()
	SetSutBaseScheme(sutScheme)
	SetSutBaseUri(sutIp)
	setSutName(Temp.Sut.Name)
	SetSutBaseUriToken(sutIp, token)
	var respList []ResponseMsg
	var res ResponseMsg
	var valResult string
	ok, msg := Ping(Temp.Sut.IpAddress, Temp.Sut.Protocol, "sut")
	if !ok {
		res.Name = Temp.Procedure.ProcedureName
		res.StatusCode = "500"
		res.ValidationResult = "Fail"
		res.Response = msg
		respList = append(respList, res)
		finalresp = append(finalresp, respList)
		return finalresp, nil
	}
	defaultReqBody, err1 := configure5ge2e(Temp)
	if err1 != nil {
		fmt.Println("Error", err1)
		return finalresp, err1
	}
	tempEndPoint := Temp.Procedure.EndPoint
	Temp.Emulated.Ipaddress = apiGateway.GenerateHost5ge2e(user_email)
	ok1, msg1 := Ping(Temp.Emulated.Ipaddress, "HTTP", "5G-E2E container")
	if !ok1 {
		res.Name = Temp.Procedure.ProcedureName
		res.StatusCode = "500"
		res.ValidationResult = "Fail"
		res.Response = msg1
		respList = append(respList, res)
		finalresp = append(finalresp, respList)
		return finalresp, nil
	}
	base_url := "http://" + Temp.Emulated.Ipaddress + tempEndPoint
	fmt.Println(base_url)

	reqBody, _ := json.Marshal(defaultReqBody)
	payload := bytes.NewReader(reqBody)
	fmt.Println(string(reqBody))
	req, err := http.NewRequest(Temp.Procedure.RequestType, base_url, payload)
	if err != nil {
		return finalresp, err
	}
	req.Header.Add("Accept", "*/*") /*   */
	req.Header.Add("Content-Length", strconv.Itoa(len(string(reqBody))))
	req.Header.Add("Content-Type", "Application/json")
	resp, err := client.Do(req)
	if err != nil {
		return finalresp, err
	}
	if strconv.Itoa(resp.StatusCode) == Temp.Procedure.ExpectedStatusCode {
		valResult = "Pass"
	} else {
		valResult = "Fail"
	}
	res.StatusCode = strconv.Itoa(resp.StatusCode)

	res.ValidationResult = valResult
	res.Name = Temp.Procedure.ProcedureName
	var Respdata5ge2e RespData5gE2e
	if res.StatusCode == "204" {
		res.Response = Respdata5ge2e
		Respdata5ge2e.ConfigPath = ""
		Respdata5ge2e.Protocol = "NGAP"
	} else {
		bod, _ := io.ReadAll(resp.Body)
		var j interface{}
		_ = json.Unmarshal(bod, &j)
		Respdata5ge2e.Response = j
		Respdata5ge2e.ConfigPath = ""
		dateTimeArr := strings.Split(time.Now().String(), " ")
		filetime := dateTimeArr[0] + "_" + dateTimeArr[1]
		logOutputPath := "/home/cicdtools/NfstubLogs/5ge2eConfig/" + filetime + ".json"
		f, er := os.Create(logOutputPath)
		if er != nil {
			fmt.Println(er)
		}
		_, _ = f.Write(reqBody)
		Respdata5ge2e.Protocol = "NGAP"
		Respdata5ge2e.ConfigPath = logOutputPath
		res.Response = Respdata5ge2e
	}
	respList = append(respList, res)

	logrus.WithFields(logrus.Fields{
		// "Body": Temp,
		"TestSequenceId": testSeqId,
		"User":           user_email,
		// "Emulated_Node":    Temp.Messages[0].Name,
		// "Emulated_Node_IP": Temp.Messages[0].Ipaddress,
		"SUT_Name": Temp.Sut.Name,
		"SUT_IP":   Temp.Sut.IpAddress,
		"Action":   "Initiate Test",
		// "Result":           resultList,
		// "Test_Messages":    Temp.Messages,
		"EmulatedIP":           Temp.Emulated.Ipaddress,
		"EmulatedName":         Temp.Emulated.Name,
		"RequestMessageConfig": Temp.Procedure.Configs,
		"ExpectedStatusCode":   Temp.Procedure.ExpectedStatusCode,
		"MessageName":          Temp.Procedure.ProcedureName,
		"Result":               valResult,
		"Response":             res,
	}).Info("Initiate Test")
	finalresp = append(finalresp, respList)
	fmt.Println(finalresp)
	var tmp TestStruct
	if len(TS) > 0 {
		tmp.Sut = TS[0].Sut
		tmp.Emulated = TS[0].Emulated
	}
	TS = nil
	if len(TS) > 0 {
		TS = append(TS, tmp)
	}
	return finalresp, nil
}

func Initiate4gE2eTest(user_email, uid string) ([][]ResponseMsg, error) {
	print := color.New(color.FgGreen, color.Bold)
	e := color.New(color.BgRed, color.Bold)
	f, err := os.OpenFile("/home/cicdtools/NfstubLogs/2nrf.log", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		e.Printf("error opening file: %v", err)
	}
	logrus.SetFormatter(&logrus.JSONFormatter{})
	logrus.SetOutput(f)
	logrus.SetLevel(logrus.DebugLevel)
	var finalresp [][]ResponseMsg

	var Temp TestStruct
	if len(TS) > 0 {
		// Access the first element
		Temp = TS[0]
	} else {
		return nil, fmt.Errorf("index out of range [0] with length 0")
	}
	var Req = make(map[string]interface{})

	for i := 0; i < len(Temp.Supporting_Node); i++ {

		Req[Temp.Supporting_Node[i].Node] = Temp.Supporting_Node[i].ActiveNodeIp + "," + Temp.Supporting_Node[i].StandByNodeIp
	}
	Temp.Sut.Interface = ""
	client := &http.Client{}
	token := Temp.Sut.Token
	sutScheme := Temp.Sut.Protocol
	Temp.Sut.Interface = ""
	sutIp := sutScheme + "://" + Temp.Sut.IpAddress

	testSeqId := uuid.New().String()
	SetSutBaseScheme(sutScheme)
	SetSutBaseUri(sutIp)
	setSutName(Temp.Sut.Name)
	SetSutBaseUriToken(sutIp, token)
	var respList []ResponseMsg
	var res ResponseMsg
	var valResult string

	b_url := "/release?"
	if !Temp.Release.RequestBodyCorrection {
		b_url += "correctRequestBody=false"
	} else {
		b_url += "correctRequestBody=true"
	}
	if Temp.Release.ReleaseValue == "" {
		Temp.Release.ReleaseValue = "14"
	}
	tempEndPoint := Temp.Procedure.EndPoint
	fmt.Println("end point:", tempEndPoint)

	var base_url string
	ok, msg := Ping(Temp.Sut.IpAddress, Temp.Sut.Protocol, "MME")

	if !ok {
		res.Name = Temp.Procedure.ProcedureName
		res.StatusCode = "500"
		res.ValidationResult = "Fail"
		res.Response = msg
		respList = append(respList, res)
		finalresp = append(finalresp, respList)

		return finalresp, nil
	}
	Temp.Emulated.Ipaddress = apiGateway.GenerateHost4ge2e(user_email)
	//	Temp.Emulated.Ipaddress ="10.254.12.142:8001"
	IP := strings.Split(Temp.Emulated.Ipaddress, ":")
	fmt.Println("emulated ip", Temp.Emulated.Ipaddress)
	ok1, msg1 := Ping(Temp.Emulated.Ipaddress, "HTTP", "4G-E2E container")
	if !ok1 {
		res.Name = Temp.Procedure.ProcedureName
		res.StatusCode = "500"
		res.ValidationResult = "Fail"
		res.Response = msg1
		respList = append(respList, res)
		finalresp = append(finalresp, respList)
		return finalresp, nil
	}
	mmeAddrData := strings.Split(Temp.Sut.IpAddress, ":")
	// base_url = "http://" + Temp.Emulated.Ipaddress + tempEndPoint + "?release=" + Temp.Release.ReleaseValue + "&mmeip=" + mmeAddrData[0] + "&uid=" + uid + "&hostip=" + IP[0] + "&supporting_node=" + supporting_node
	base_url = "http://" + Temp.Emulated.Ipaddress + tempEndPoint + "?release=" + Temp.Release.ReleaseValue + "&uid=" + uid
	fmt.Println("base_url:", base_url)

	var jsdata []byte

	// var dtaa []string
	for i := 0; i < len(Temp.Procedure.Configs); i++ {
		Req[Temp.Procedure.Configs[i].FileName] = Temp.Procedure.Configs[i].FileBody
	}
	Req["MME_IP"] = mmeAddrData[0]
	Req["hostip"] = IP[0]
	print.Println("\n\n\n data =", Req)
	jsdata, _ = json.Marshal(Req)

	payload := strings.NewReader(string(jsdata))
	var RespData4GE2E RespData4GE2E
	message_config := fmt.Sprintf("%v", Req["message_config"])
	split_msg := strings.Split(message_config, "IMSI:")
	s := strings.Split(split_msg[1], " ")
	IMSI := s[0]
	num, _ := strconv.ParseFloat(IMSI, 64)
	simpleImsi := fmt.Sprintf("%.f", num)
	reqId := uuid.New().String()
	print.Println("CDR VALidation is ", Temp.Cdr_Validation)

	req, err := http.NewRequest(Temp.Procedure.RequestType, base_url, payload)
	req.Header.Add("Content-Type", "application/json")
	if err != nil {
		return finalresp, err
	}
	req.Header.Add("Accept", "*/*") /*   */
	resp, err := client.Do(req)
	if err != nil {
		return finalresp, err
	}

	res.Name = Temp.Procedure.ProcedureName

	bod, _ := io.ReadAll(resp.Body)
	err = json.Unmarshal(bod, &RespData4GE2E.Data)
	if err != nil {
		e.Println(err)
	}
	print.Println("Response ", RespData4GE2E.Data.Status)

	RespData4GE2E.Release = Temp.Release.ReleaseValue
	RespData4GE2E.Request_Id = reqId
	currentTime := time.Now()
	// Format the current date and time
	formattedTime := currentTime.Format("2006-01-02 15:04:05")
	//CDR validation
	if Temp.Cdr_Validation {
		time.Sleep(30 * time.Second)
		Info := make(map[string]string)
		Info["imsi"] = simpleImsi
		Info["toolname"] = "TestFramework"
		Info["time"] = formattedTime
		print.Println("Time:", formattedTime)
		user_email := strings.Split(user_email, "@")
		var user string
		if user_email[0] == "" {
			user = "default"
		}
		user = user_email[0]
		status, result := spirentapi.GetEncodedCDRFile(Info, reqId, user, "")
		if status == 200 {
			RespData4GE2E.CdrResponse = result
		}
	}
	res.Response = RespData4GE2E

	if RespData4GE2E.Data.Status == "success" {
		valResult = "Pass"
	} else {
		valResult = "Fail"
	}
	res.StatusCode = strconv.Itoa(resp.StatusCode)
	res.ValidationResult = valResult
	respList = append(respList, res)
	logrus.WithFields(logrus.Fields{
		// "Body": Temp,
		"TestSequenceId": testSeqId,
		"User":           user_email,
		// "Emulated_Node":    Temp.Messages[0].Name,
		// "Emulated_Node_IP": Temp.Messages[0].Ipaddress,
		"SUT_Name": Temp.Sut.Name,
		"SUT_IP":   Temp.Sut.IpAddress,
		"Action":   "Initiate Test",
		// "Result":           resultList,
		// "Test_Messages":    Temp.Messages,
		"EmulatedIP":           Temp.Emulated.Ipaddress,
		"EmulatedName":         Temp.Emulated.Name,
		"RequestMessageConfig": Temp.Procedure.Configs,
		"ExpectedStatusCode":   Temp.Procedure.ExpectedStatusCode,
		"MessageName":          Temp.Procedure.ProcedureName,
		"Result":               valResult,
		"Response":             res,
	}).Info("Initiate Test")

	finalresp = append(finalresp, respList)

	var tmp TestStruct
	if len(TS) > 0 {
		tmp.Sut = TS[0].Sut
		tmp.Emulated = TS[0].Emulated
	}
	TS = nil
	if len(TS) > 0 {
		TS = append(TS, tmp)
	}

	return finalresp, nil
}

var Decoded_CSV = make(map[string][]byte, 15)
var Cdr_Validation_result = make(map[string]interface{}, 15)
var csv_file_name string

func decode(s string) string {
	fmt.Println(s)
	data, _ := hex.DecodeString(s)

	return string(data)
}
func InitiateInterratTest(user_email, uid string) ([][]ResponseMsg, error) {
	f, err := os.OpenFile("/home/cicdtools/NfstubLogs/2nrf.log", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		fmt.Printf("error opening file: %v", err)
	}
	logrus.SetFormatter(&logrus.JSONFormatter{})
	logrus.SetOutput(f)
	logrus.SetLevel(logrus.DebugLevel)
	var finalresp [][]ResponseMsg
	Temp := TS[0]
	fmt.Println(Temp)
	Temp.Sut.Interface = ""
	client := &http.Client{}
	token := Temp.Sut.Token
	sutScheme := Temp.Sut.Protocol
	Temp.Sut.Interface = ""
	sutIp := sutScheme + "://" + Temp.Sut.IpAddress

	testSeqId := uuid.New().String()
	SetSutBaseScheme(sutScheme)
	SetSutBaseUri(sutIp)
	setSutName(Temp.Sut.Name)
	SetSutBaseUriToken(sutIp, token)
	var respList []ResponseMsg
	var res ResponseMsg
	ok, msg := Ping(Temp.Sut.IpAddress, Temp.Sut.Protocol, "sut")
	if !ok {
		res.Name = Temp.Procedure.ProcedureName
		res.StatusCode = "500"
		res.ValidationResult = "Fail"
		res.Response = msg
		respList = append(respList, res)
		finalresp = append(finalresp, respList)
		return finalresp, nil
	}
	var valResult string

	b_url := "/release?"
	if !Temp.Release.RequestBodyCorrection {
		b_url += "correctRequestBody=false"
	} else {
		b_url += "correctRequestBody=true"
	}
	if Temp.Release.ReleaseValue == "" {
		Temp.Release.ReleaseValue = "14"
	}
	tempEndPoint := Temp.Procedure.EndPoint
	fmt.Println(tempEndPoint)

	var base_url string
	// if Temp.Emulated.Ipaddress == "" {
	// 	Temp.Emulated.Ipaddress = "10.254.12.108:9142"
	// }
	Temp.Emulated.Ipaddress = apiGateway.GenerateHostInterrat(user_email)
	fmt.Println("Emulated ->", Temp.Emulated.Ipaddress)
	//Check flask Server

	ok1, msg1 := Ping(Temp.Emulated.Ipaddress, "HTTP", "Interrat Container")
	if !ok1 {
		res.Name = Temp.Procedure.ProcedureName
		res.StatusCode = "500"
		res.ValidationResult = "Fail"
		res.Response = msg1
		respList = append(respList, res)
		finalresp = append(finalresp, respList)
		return finalresp, nil
	}
	mmeAddrData := strings.Split(Temp.Sut.IpAddress, ":")
	base_url = "http://" + Temp.Emulated.Ipaddress + tempEndPoint + "?release=" + Temp.Release.ReleaseValue + "&mmeip=" + mmeAddrData[0] + "&token=" + token + "&uid=" + uid

	fmt.Println("my url:" + base_url)

	var jsdata []byte
	var Req = make(map[string]interface{})
	// var dtaa []string
	for i := 0; i < len(Temp.Procedure.Configs); i++ {
		Req[Temp.Procedure.Configs[i].FileName] = Temp.Procedure.Configs[i].FileBody
	}
	fmt.Println("url = ", Req)
	jsdata, _ = json.Marshal(Req)

	payload := strings.NewReader(string(jsdata))
	req, err := http.NewRequest(Temp.Procedure.RequestType, base_url, payload)
	fmt.Println(req)
	// req.Header.Add("Accept", "application/json")
	req.Header.Add("Content-Type", "application/json")
	if err != nil {
		return finalresp, err
	}
	req.Header.Add("Accept", "*/*") /*   */
	resp, err := client.Do(req)
	if err != nil {
		return finalresp, err
	}

	res.Name = Temp.Procedure.ProcedureName
	var RespData4GE2E RespData4GE2E
	bod, _ := io.ReadAll(resp.Body)
	fmt.Println("Response", string(bod))
	err = json.Unmarshal(bod, &RespData4GE2E.Data)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("Response ", RespData4GE2E.Data.Status)

	RespData4GE2E.Release = Temp.Release.ReleaseValue
	res.Response = RespData4GE2E

	if RespData4GE2E.Data.Status == "success" {
		valResult = "Pass"
	} else {
		valResult = "Fail"
	}
	res.StatusCode = strconv.Itoa(resp.StatusCode)

	res.ValidationResult = valResult
	respList = append(respList, res)
	logrus.WithFields(logrus.Fields{
		// "Body": Temp,
		"TestSequenceId": testSeqId,
		"User":           user_email,
		// "Emulated_Node":    Temp.Messages[0].Name,
		// "Emulated_Node_IP": Temp.Messages[0].Ipaddress,
		"SUT_Name": Temp.Sut.Name,
		"SUT_IP":   Temp.Sut.IpAddress,
		"Action":   "Initiate Test",
		// "Result":           resultList,
		// "Test_Messages":    Temp.Messages,
		"EmulatedIP":           Temp.Emulated.Ipaddress,
		"EmulatedName":         Temp.Emulated.Name,
		"RequestMessageConfig": Temp.Procedure.Configs,
		"ExpectedStatusCode":   Temp.Procedure.ExpectedStatusCode,
		"MessageName":          Temp.Procedure.ProcedureName,
		"Result":               valResult,
		"Response":             res,
	}).Info("Initiate Test")

	finalresp = append(finalresp, respList)

	var tmp TestStruct
	if len(TS) > 0 {
		tmp.Sut = TS[0].Sut
		tmp.Emulated = TS[0].Emulated
	}
	TS = nil
	if len(TS) > 0 {
		TS = append(TS, tmp)
	}
	return finalresp, nil
}

var Detach_Map = map[string]string{
	"Test Attach User Initiated Detach": "/detachUe",
}

func DetachRequests(c *gin.Context) {
	user_email := apiGateway.FetchUserEmail(c)
	message_name := c.Param("message")
	fmt.Println(message_name)
	IP := apiGateway.GenerateHost4ge2e(user_email)
	URL := "http://" + IP + "/detachUe"
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)

}


func HTMLFileDownloadSpirent(c *gin.Context) {
	config := Configuration.ReadConfig()
	filename := c.Param("filename")
	host := config.CDR.Forward_Spirent_Host.IP + ":" + config.CDR.Forward_Spirent_Host.Port

	URL := "http://" + host + "/GetFileToDownload/" + filename
	fmt.Println(URL)
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
		c.JSON(http.StatusInternalServerError, err)
	}
	defer response.Body.Close()
	if response.StatusCode != 200 {
		c.JSON(http.StatusInternalServerError, "Unable to Download")
	}
	c.Header("Content-Type", "text/html")
	// bod, _ := io.ReadAll(response.Body)
	_, err = io.Copy(c.Writer, response.Body)
	if err != nil {
		fmt.Println("G3")
		fmt.Println(err)
	}
}

func Show_Spirent_Diagram(c *gin.Context) {
	config := Configuration.ReadConfig()
	IP := config.CDR.Forward_Spirent_Host.IP + ":" + config.CDR.Forward_Spirent_Host.Port
	filename := c.Param("filename")
	URL := "http://" + IP + "/GetFileToDownload/" + filename
	fmt.Println(URL)
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	//       var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	/*   err = json.Unmarshal(bod, &resp)
	     if err != nil {
	             fmt.Println(err)
	     }*/
	c.Header("Content-Type", "text/html")
	c.String(http.StatusOK, string(bod))
}

func Log_Analysis_Diagram(c *gin.Context) {
	user_email := apiGateway.FetchUserEmail(c)
	IP := apiGateway.GenerateHost4ge2e(user_email)
	URL := "http://" + IP + "/generate_diagram"
	// Parse the multipart form data
	err := c.Request.ParseMultipartForm(10 << 20) // 10 MB limit
	if err != nil {
		fmt.Println("error 1")
	}
	client := &http.Client{}
	var buffer bytes.Buffer
	writer := multipart.NewWriter(&buffer)
	fmt.Println(c.Request.MultipartForm.File)
	for _, fileHeaders := range c.Request.MultipartForm.File {
		for _, file := range fileHeaders {
			srcFile, err := file.Open()
			if err != nil {
				fmt.Println("error 2")
			}
			defer srcFile.Close()
			fileField, err := writer.CreateFormFile("file", file.Filename)
			if err != nil {
				fmt.Println("error 3")
			}

			if _, err := io.Copy(fileField, srcFile); err != nil {
				fmt.Println("error 4")
			}

		}
	}
	writer.Close()
	req, err := http.NewRequest("POST", URL, &buffer)
	if err != nil {
		fmt.Println("error 5")
	}
	// Set the content type from the writer
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Make the request
	response, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
	}
	defer response.Body.Close()
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)
}

func Log_Analysis(c *gin.Context) {
	Config_file := Configuration.ReadConfig()
	analysis_type := c.Query("analysis_type")
	imsi := c.Query("imsi")
	Cdr_Validator_Server = Config_file.CDR.Log_Analysis.IP + ":" + Config_file.CDR.Log_Analysis.Port
	URL := "http://" + Cdr_Validator_Server + "/log_analysis?analysis_type=" + analysis_type + "&imsi=" + imsi
	// Parse the multipart form data
	err := c.Request.ParseMultipartForm(10 << 20) // 10 MB limit
	if err != nil {
		fmt.Println("error 1")
	}
	client := &http.Client{}
	var buffer bytes.Buffer
	writer := multipart.NewWriter(&buffer)
	fmt.Println(c.Request.MultipartForm.File)
	for _, fileHeaders := range c.Request.MultipartForm.File {
		for _, file := range fileHeaders {
			srcFile, err := file.Open()
			if err != nil {
				fmt.Println("error 2")
			}
			defer srcFile.Close()
			fileField, err := writer.CreateFormFile("file", file.Filename)
			if err != nil {
				fmt.Println("error 3")
			}

			if _, err := io.Copy(fileField, srcFile); err != nil {
				fmt.Println("error 4")
			}

		}
	}
	writer.Close()
	req, err := http.NewRequest("POST", URL, &buffer)
	if err != nil {
		fmt.Println("error 5")
	}
	// Set the content type from the writer
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Make the request
	response, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
	}
	defer response.Body.Close()
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)
}

func ScrapEms(c *gin.Context) {
	node := c.Param("node")
	URL := "http://scrap_ems/" + node
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)

}
func FormMultipartRequest(file_name string, reqBody []byte) (*bytes.Buffer, *multipart.Writer) {
	reader := bytes.NewReader(reqBody)
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile("file", file_name)
	if err != nil {
		fmt.Println("Errors:", err)
	}
	_, err = io.Copy(part, reader)
	if err != nil {
		fmt.Println("Error1:", err)
	}
	writer.Close()
	return body, writer
}
func CDRValidation(c *gin.Context) {
	Config_file := Configuration.ReadConfig()
	start_time := c.Query("start_time")
	served_imsi := c.Query("served_imsi")
	cdr_type := c.Query("type")
	time_limit := c.Query("time_limit")
	volume_limit := c.Query("volume_limit")
	Call_type := c.Query("call_type")
	fmt.Println("Served imsi", served_imsi)
	//	fmt.Println("time_limit",time_limit,"\nvolume_limit",volume_limit)
	Cdr_Validator_Server = Config_file.CDR.CDR_Validator_Host.IP + ":" + Config_file.CDR.CDR_Validator_Host.Port
	URL := "http://" + Cdr_Validator_Server + "/cdr_validation?type=" +
		cdr_type + "&start_time=" + start_time + "&served_imsi=" + served_imsi +
		"&time_limit=" + time_limit + "&volume_limit=" + volume_limit +
		"&call_type=" + Call_type + "&initiated_by=user"
	fmt.Println("URL:", URL)
	// Parse the multipart form data
	err := c.Request.ParseMultipartForm(10 << 20) // 10 MB limit
	if err != nil {
		fmt.Println("error 1")
	}
	client := &http.Client{}
	var buffer bytes.Buffer
	writer := multipart.NewWriter(&buffer)
	fmt.Println(c.Request.MultipartForm.File)
	for _, fileHeaders := range c.Request.MultipartForm.File {
		for _, file := range fileHeaders {
			srcFile, err := file.Open()
			if err != nil {
				fmt.Println("error 2")
			}
			defer srcFile.Close()
			fileField, err := writer.CreateFormFile("file", file.Filename)
			if err != nil {
				fmt.Println("error 3")
			}

			if _, err := io.Copy(fileField, srcFile); err != nil {
				fmt.Println("error 4")
			}

		}
	}
	writer.Close()

	req, err := http.NewRequest("POST", URL, &buffer)
	if err != nil {
		fmt.Println("error 5")
	}
	// Set the content type from the writer
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Make the request
	response, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
	}
	defer response.Body.Close()
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)

}

func GetCDRSheetData(c *gin.Context) {
	Config_file := Configuration.ReadConfig()
	message_name := c.Param("message")
	Cdr_Validator_Server = Config_file.CDR.CDR_Validator_Host.IP + ":" + Config_file.CDR.CDR_Validator_Host.Port
	URL := "http://" + Cdr_Validator_Server + "/edit_sheet?sheet_type=" + message_name
	fmt.Println("URL", URL)
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
	}
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}

	c.JSON(http.StatusOK, resp)

}

func EditCDRSheetData(c *gin.Context) {
	Config_file := Configuration.ReadConfig()
	message_name := c.Param("message")
	client := &http.Client{}
	Cdr_Validator_Server = Config_file.CDR.CDR_Validator_Host.IP + ":" + Config_file.CDR.CDR_Validator_Host.Port
	URL := "http://" + Cdr_Validator_Server + "/edit_sheet?sheet_type=" + message_name
	jsonData, err := io.ReadAll(c.Request.Body)
	if err != nil {
		fmt.Println(err)
	}
	req, err := http.NewRequest("POST", URL, bytes.NewBuffer(jsonData))

	if err != nil {
		fmt.Println(err)
	}

	req.Header.Add("Content-Type", "application/json")
	response, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
	}
	defer response.Body.Close()
	var resp interface{}
	bod, _ := io.ReadAll(response.Body)
	fmt.Println("body:", string(bod))
	err = json.Unmarshal(bod, &resp)
	if err != nil {
		fmt.Println(err)
	}
	c.JSON(http.StatusOK, resp)

}

func HTMLFileDownload(c *gin.Context) {
	config := Configuration.ReadConfig()
	filename := c.Param("filename")
	host := config.Docker_Containers["E2e4g"][0].IP + ":" + config.Docker_Containers["E2e4g"][0].Port
	URL := "http://" + host + "/download/html/" + filename
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
		c.JSON(http.StatusInternalServerError, err)
	}
	defer response.Body.Close()
	if response.StatusCode != 200 {
		c.JSON(http.StatusInternalServerError, "Unable to Download")
	}
	c.Header("Content-Type", "text/html")
	// bod, _ := io.ReadAll(response.Body)
	_, err = io.Copy(c.Writer, response.Body)
	if err != nil {
		fmt.Println("G3")
		fmt.Println(err)
	}
}

func HTMLFileDownloadSpirent(c *gin.Context) {
	config := Configuration.ReadConfig()
	filename := c.Param("filename")
	host := config.CDR.Forward_Spirent_Host.IP + ":" + config.CDR.Forward_Spirent_Host.Port

	URL := "http://" + host + "/GetFileToDownload/" + filename
	fmt.Println(URL)
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
		c.JSON(http.StatusInternalServerError, err)
	}
	defer response.Body.Close()
	if response.StatusCode != 200 {
		c.JSON(http.StatusInternalServerError, "Unable to Download")
	}
	c.Header("Content-Type", "text/html")
	// bod, _ := io.ReadAll(response.Body)
	_, err = io.Copy(c.Writer, response.Body)
	if err != nil {
		fmt.Println("G3")
		fmt.Println(err)
	}
}

func DownloadWiresharkFileforSpirent(c *gin.Context) {
	config := Configuration.ReadConfig()
	filename := c.Param("filename")
	IP := config.CDR.Forward_Spirent_Host.IP + ":" + config.CDR.Forward_Spirent_Host.Port
	URL := "http://" + IP + "/GetFileToDownload/" + filename
	fmt.Println(URL)
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println("hello")
		c.JSON(http.StatusInternalServerError, err)
	}

	defer response.Body.Close()
	fmt.Println(response.StatusCode)
	if response.StatusCode != 200 {
		c.JSON(http.StatusInternalServerError, "Unable to Download")
	}
	_, err = io.Copy(c.Writer, response.Body)
	if err != nil {
		fmt.Println("G3")
		fmt.Println(err)
	}
	c.JSON(200, "File downloaded")
}

func DownloadWiresharkFile(c *gin.Context) {
	user_email := apiGateway.FetchUserEmail(c)
	filename := c.Param("filename")
	IP := apiGateway.GenerateHost4ge2e(user_email)
	if strings.Contains(filename, "interrat") {
		IP = apiGateway.GenerateHostInterrat(user_email)
	}
	URL := "http://" + IP + "/download/" + filename
	response, err := http.Get(URL)
	if err != nil {
		fmt.Println(err)
		c.JSON(http.StatusInternalServerError, err)
	}
	defer response.Body.Close()
	if response.StatusCode != 200 {
		c.JSON(http.StatusInternalServerError, "Unable to Download")
	}
	_, err = io.Copy(c.Writer, response.Body)
	if err != nil {
		fmt.Println("G3")
		fmt.Println(err)
	}
	c.JSON(200, "File downloaded")
}
============================================================================

func ReadSpirentSut(c *gin.Context) {
	var COLL_NAME1 = "spirent_sut_config"
	var collection1 *mongo.Collection = database.OpenCollection(COLL_NAME1)
	var sut []Spirent_sut_Config
	cur, err := collection1.Find(context.TODO(), bson.M{})
	if err != nil {
		// fmt.Println(err)
		log.Println(err)
		c.IndentedJSON(http.StatusInternalServerError, gin.H{
			"status":  http.StatusInternalServerError,
			"message": "Database Error",
			"error":   err.Error(),
		})
		return
	}
	for cur.Next(context.TODO()) {
		var elem Spirent_sut_Config
		err := cur.Decode(&elem)
		if err != nil {
			// fmt.Println(err)
			log.Println(err)
			c.IndentedJSON(http.StatusInternalServerError, gin.H{
				"status":  http.StatusInternalServerError,
				"message": "Database Decode Error",
				"error":   err.Error(),
			})
			return
		}
		sut = append(sut, elem)
	}
	if err := cur.Err(); err != nil {
		// fmt.Println(err)
		c.IndentedJSON(http.StatusInternalServerError, gin.H{
			"status":  http.StatusInternalServerError,
			"message": "Database Error",
			"error":   err.Error(),
		})
		return
	}
	cur.Close(context.TODO())
	c.IndentedJSON(http.StatusOK, gin.H{
		"status":  http.StatusOK,
		"message": "Success",
		"data":    sut,
	})
}
